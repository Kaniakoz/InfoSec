 - [1. RSA (Rivestâ€“Shamirâ€“Adleman)](#1-rsa)
- [2. Diffie-Hellman Key Exchange](#2-diffie-hellman)
- [3. Elliptic Curve Cryptography (ECC)](#3-ecc)

{1-rsa}
## 1. RSA (Rivestâ€“Shamirâ€“Adleman) 

RSA is an **asymmetric encryption algorithm** and the foundation of public-key cryptography. It leverages the mathematical difficulty of factoring the product of two large prime numbers.

| | |
|---|---|
| **Applications** | Secure data transmission, digital signatures, SSL/TLS |
| **Mathematical basis** | Large prime numbers and modular arithmetic |

---

### 1.1 Mathematical Foundations

#### Euler's Totient Function Ï†(n)

Ï†(n) counts how many positive integers up to n are **coprime** to n (share no common factor other than 1). Two numbers are coprime if their GCD = 1.

- For a prime `p`: Ï†(p) = p âˆ’ 1 (all numbers less than p are coprime to it)
- For `n = p Ã— q` (product of two primes): **Ï†(n) = (pâˆ’1)(qâˆ’1)**

> ğŸ“ **Example:** Ï†(10) = 4, because {1, 3, 7, 9} are the integers coprime with 10.

#### Euler's Theorem

If `gcd(a, n) = 1`, then:

```
a^Ï†(n) â‰¡ 1 (mod n)
```

This guarantees that modular exponentiation in RSA is invertible.

#### Fermat's Little Theorem

A special case of Euler's Theorem when n is prime (p):

```
a^(pâˆ’1) â‰¡ 1 (mod p)
```

Simplifies modular inverse calculations in key generation. Euler's Theorem generalises this to composite moduli like n = p Ã— q.

---

### 1.2 RSA Key Generation

1. Choose two distinct large primes **p** and **q**
2. Compute **n = p Ã— q** (the public modulus)
3. Compute **Ï†(n) = (pâˆ’1)(qâˆ’1)** (kept secret)
4. Choose public exponent **e** such that `1 < e < Ï†(n)` and `gcd(e, Ï†(n)) = 1`
5. Compute private key **d** â€” the modular inverse of e mod Ï†(n):

```
d Ã— e â‰¡ 1 (mod Ï†(n))
```

**Public key:** `(n, e)` Â· **Private key:** `d`

---

### 1.3 Encryption and Decryption

| Operation | Formula |
|---|---|
| **Encrypt** | `c = m^e mod n` (m = plaintext, c = ciphertext) |
| **Decrypt** | `m = c^d mod n` |

> ğŸ“ This works because of Euler's Theorem: raising to the power `e Ã— d â‰¡ 1 (mod Ï†(n))` returns the original message.

---

### 1.4 The Extended Euclidean Algorithm (Finding d)

The modular inverse d is found via the Extended Euclidean Algorithm, which computes gcd(a, b) and finds integers x, y satisfying **BÃ©zout's identity**:

```
aÂ·x + bÂ·y = gcd(a, b)
```

In RSA, this finds d such that `eÂ·d + Ï†(n)Â·y = 1`.

**Standard Euclidean Algorithm steps:**
1. Given a and b where a > b, divide: `a = b Ã— q + r`
2. Replace a â† b, b â† r and repeat
3. Stop when remainder = 0; the last non-zero remainder is the GCD
4. Back-substitute to express GCD as a linear combination (Extended version)

#### Worked Example: p = 61, q = 53, e = 17

```
n = 61 Ã— 53 = 3233
Ï†(n) = (61âˆ’1)(53âˆ’1) = 60 Ã— 52 = 3120
Find d such that 17Â·d â‰¡ 1 (mod 3120)
Extended Euclidean â†’ d = âˆ’367 â‰¡ 3120 âˆ’ 367 = 2753 (mod 3120)

Public key: (3233, 17)   |   Private key: 2753

Encrypt m = 65:   c = 65^17 mod 3233 = 2790
Decrypt:          m = 2790^2753 mod 3233 = 65  âœ“
```

---

### 1.5 RSA Security

RSA security rests on the **computational hardness of integer factorisation**:

- The public modulus n is published, but n = p Ã— q with p, q kept secret
- To find Ï†(n) and thus d, an attacker must factorise n into p and q
- Factorising large numbers (2048-bit+) is computationally infeasible with current technology

> ğŸ“ **Key insight:** Multiplying p Ã— q to get n is trivial. Reversing it â€” factoring n back into p and q â€” is astronomically hard.

---

## 2. Diffie-Hellman Key Exchange {#2-diffie-hellman}

Diffie-Hellman (DH) allows two parties to establish a **shared secret key over a public channel** without ever transmitting the secret itself.

| | |
|---|---|
| **Security basis** | The Discrete Logarithm Problem (DLP) |
| **Applications** | SSL/TLS session keys, VPNs, secure messaging |

---

### 2.1 Related Mathematical Theories

#### Discrete Logarithm Problem (DLP)

Given `g`, `p` (prime), and `A = g^a mod p`, finding exponent `a` is computationally hard for large p. This asymmetry secures DH.

#### Modular Exponentiation

Computing `g^a mod p` is fast (even for huge numbers) using repeated squaring. Recovering `a` from the result is not.

---

### 2.2 Key Exchange Process

1. **Public agreement:** Alice and Bob agree on a large prime `p` and a generator `g`
2. **Private keys:** Alice secretly chooses `a`; Bob secretly chooses `b`
3. **Public keys:** Alice computes `A = g^a mod p`; Bob computes `B = g^b mod p`
4. **Exchange:** Alice sends A to Bob; Bob sends B to Alice
5. **Shared secret:** Both compute S independently:

```
Alice: S = B^a mod p = (g^b)^a mod p = g^(ab) mod p
Bob:   S = A^b mod p = (g^a)^b mod p = g^(ab) mod p
```

> ğŸ“ An attacker knows g, p, A, and B but cannot compute `S = g^(ab) mod p` without solving the DLP.

---

### 2.3 Choosing the Generator g

`g` must be a **primitive root modulo p** â€” meaning its powers `{g^1, g^2, ..., g^(p-1)} mod p` generate all integers from 1 to pâˆ’1.

- Ensures maximum key space and uniform distribution of public keys
- Small values (g = 2, 3, 5) are often used for efficiency if they are primitive roots of p
- If g generates only a small subset, security is severely weakened

**Example (p = 7):**

```
g = 3: powers mod 7 â†’ 3, 2, 6, 4, 5, 1  âœ“  generates all {1..6}
g = 2: powers mod 7 â†’ 2, 4, 1, 1, 2, 1  âœ—  does NOT generate all values
```

â†’ g = 3 is a primitive root mod 7; g = 2 is not.

---

### 2.4 Choosing Private Keys

- Must be random and uniform from {1, 2, ..., pâˆ’1}
- Key size â‰¥ 2048 bits for modern security
- Weak or small private keys enable brute force or Pohlig-Hellman attacks

> ğŸ“ 2048 bits â‰ˆ 10^600 possible values â€” practically infeasible to brute force.

---

### 2.5 DH Security Summary

Security relies entirely on the DLP. Even with `p`, `g`, `A`, and `B` publicly known, computing the shared secret `g^(ab) mod p` without knowing `a` or `b` is computationally infeasible for large parameters.

---

## 3. Elliptic Curve Cryptography (ECC) {#3-ecc}

ECC achieves the **same security as RSA with much smaller key sizes** â€” ideal for constrained environments.

| | |
|---|---|
| **Key size comparison** | 256-bit ECC â‰ˆ 3072-bit RSA in security strength |
| **Applications** | SSL/TLS, Bitcoin, secure messaging, ECDH |

---

### 3.1 Core Mathematical Concepts

#### Elliptic Curve Equation

An elliptic curve over a finite field F_p:

```
yÂ² = xÂ³ + ax + b  (mod p)
```

where a and b define the curve shape, and p is prime. Points (x, y) satisfying this form the cryptographic group.

#### Point Addition

Two points P and Q on the curve can be "added" to get a third point R, following specific geometric/algebraic rules.

#### Point Doubling

When P = Q, a special doubling formula is used (the chord becomes a tangent).

#### Point Multiplication (Scalar Multiplication)

Multiplying point P by integer k using the "double-and-add" algorithm:

```
kP = P + P + P + ... (k times)
```

> ğŸ“ Computing kP from P is fast. Recovering k from kP and P is the **Elliptic Curve Discrete Logarithm Problem (ECDLP)** â€” computationally hard.

---

### 3.2 Elliptic Curve Diffie-Hellman (ECDH)

DH key exchange on elliptic curves â€” point multiplication replaces modular exponentiation:

1. **Public parameters:** Curve E, prime p, base point G (with large prime order n)
2. **Private keys:** Alice chooses secret `a`; Bob chooses secret `b`
3. **Public keys:** Alice: `A = aG`; Bob: `B = bG`
4. **Shared secret:**

```
Alice: S = aÂ·B = a(bG) = abG
Bob:   S = bÂ·A = b(aG) = abG   â† same point!
```

The shared point S (typically its x-coordinate or a hash of it) becomes the symmetric key.

---