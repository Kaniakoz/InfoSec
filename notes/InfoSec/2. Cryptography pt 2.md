
### 1. DOUBLE TRANSPOSITION CIPHER

#### **Encryption Process**

**Step 1**: Arrange plaintext into a matrix M

- Matrix has rows and columns depending on message length
- Pad with extra characters if message doesn't fit perfectly

**Step 2**: Apply row permutation

- Multiply matrix M with permutation matrix P₁
- Premultiplication: P₁M

**Step 3**: Apply column permutation

- Postmultiply result by another permutation matrix P₂
- Result: C = P₁MP₂

**Result**: Matrix C is the ciphertext matrix

**Keys**: Permutation matrices P₁ and P₂

#### **Permutation Matrix**

- Matrix with only one "1" in each row and column
- All other entries are "0"
- Acts as rearrangement of rows/columns

#### **Example Encryption**

**Plaintext**: "HELLOWORLD" **Matrix size**: 3×4 (for simplicity)

1. **Create matrix** (pad with X):

```
H E L L
O W O R
L D X X
```

2. **P₁** (swaps row 1 and row 3):

```
┌─────┐     ┌─────┐
│0 0 1│     │L D X X│
│0 1 0│  →  │O W O R│
│1 0 0│     │H E L L│
└─────┘     └─────┘
```

3. **P₂** (swaps col 1 and col 4):

```
Apply P₂ to swap columns 1 and 4
```

**Result**: Ciphertext matrix

#### **Decryption Process**

**Step 1**: Reverse column permutation

- Multiply cipher matrix by transpose (inverse) of P₂
- P₂ᵀ acts as inverse
- Result: P₁M

**Step 2**: Reverse row permutation

- Multiply result by transpose (inverse) of P₁
- P₁ᵀ acts as inverse
- Result: M (original plaintext matrix)

**Key Property**: For permutation matrix P:

- Pᵀ = P⁻¹ (transpose equals inverse)
- P × Pᵀ = I (identity matrix)
- I × M = M (identity leaves matrix unchanged)

#### **Transpose of a Matrix**

- Obtained by swapping rows with columns
- If P swaps row 1 and row 3, Pᵀ swaps them back

**How Hard to Break?**

- Can try with simple examples online
- Tools: https://www.boxentriq.com/code-breaking/double-transposition-cipher
- Security depends on key size and randomness

---

### 2. PERFECT SECRECY

#### **Definition**

Perfect secrecy ensures that ciphertext provides **no useful information** about plaintext. Even with ciphertext, attacker gains **no knowledge** about original message.

#### **Conditions for Perfect Secrecy**

1. **Key is chosen randomly** and used only once (one-time use)
2. Given ciphertext, **any possible plaintext** of same length can be mapped to it using some key
3. **All possible plaintexts are equally probable**, so ciphertext reveals no information about original message

#### **Formal Definition Elements**

**Components of Encryption System**:

- **M**: Message space (set of all possible plaintexts)
- **C**: Ciphertext space (set of all possible ciphertexts)
- **K**: Key space (set of all possible keys)
- **G**: Key generation algorithm
- **E**: Encryption algorithm
- **D**: Decryption algorithm

**Key Properties**:

- Keys must be uniformly distributed
- Each key used with equal probability
- Encryption and decryption must be efficient

#### **Conditional Probability in Encryption (Bayes' Theorem)**

**Bayes' Theorem Applied to Encryption**:

Goal: Understand probability of particular message being plaintext given observed ciphertext.

**Formula**:

```
P(m|c) = P(c|m) × P(m) / P(c)
```

Where:

- **P(m|c)**: Probability message m was plaintext given ciphertext c observed (posterior)
- **P(c|m)**: Probability of observing ciphertext c if message m was encrypted (likelihood)
- **P(m)**: Prior probability of choosing message m
- **P(c)**: Probability of observing ciphertext c

**Interpretation**: This formula calculates likelihood that particular message a was original plaintext, given that ciphertext B was observed.

#### **Perfect Secrecy - More Formal Definition**

**Definition 1**: An encryption scheme (G,E,D) is **perfectly secret** if for every message m ∈ M and every ciphertext c ∈ C:

```
P(m|c) = P(m)
```

**Meaning**:

- Probability that message m was sent, after observing ciphertext c, is same as prior probability of choosing m, regardless of c
- Observing ciphertext does **not change** adversary's knowledge of original message

**Alternative Definition (Definition 2)**: For all m₀, m₁ ∈ M and c ∈ C:

```
P(E(K,m₀) = c) = P(E(K,m₁) = c)
```

**Meaning**:

- For any two messages, probability of producing same ciphertext is equal
- Ciphertext provides no information about which message was encrypted

---

### 3. ONE-TIME PAD (OTP) / VERNAM CIPHER

#### **Overview**

- Type of encryption offering **perfect secrecy** when used correctly
- First proposed by **Gilbert Vernam** in 1917
- Also known as **Vernam Cipher**

#### **Key Idea**

Encryption key must be:

- **As long as the message**
- **Completely random**

#### **Requirements for Perfect Secrecy**

1. Key must be **truly random**
2. Key must be **at least as long as message**
3. Key can be used **only once** (hence "one-time")
4. Both sender and receiver must **securely share the key**

#### **Encryption Process - HOW TO ENCODE**

**Example: Encrypting "HELLO"**

**Step 1**: Convert message to binary

```
Plaintext: H E L L O
Binary:
H = 01001000
E = 01000101
L = 01001100
L = 01001100
O = 01001111
```

**Step 2**: Generate random key (same length as message)

```
Random Key:
10011010 01101001 10100110 00110100 11001101
```

**Step 3**: Perform bitwise XOR operation

```
Plaintext:   01001000 01000101 01001100 01001100 01001111
Key:         10011010 01101001 10100110 00110100 11001101
          ------------------------------------------------- XOR
Ciphertext:  11010010 00101100 11101010 01111000 10000010
```

**XOR Operation Rules**:

```
0 XOR 0 = 0
0 XOR 1 = 1
1 XOR 0 = 1
1 XOR 1 = 0
```

**Result**: Ciphertext = `11010010 00101100 11101010 01111000 10000010`

#### **Decryption Process - HOW TO DECODE**

**Step 1**: Receive ciphertext

```
Ciphertext: 11010010 00101100 11101010 01111000 10000010
```

**Step 2**: Use same key (shared securely)

```
Same Key: 10011010 01101001 10100110 00110100 11001101
```

**Step 3**: Perform bitwise XOR

```
Ciphertext:  11010010 00101100 11101010 01111000 10000010
Key:         10011010 01101001 10100110 00110100 11001101
          ------------------------------------------------- XOR
Plaintext:   01001000 01000101 01001100 01001100 01001111
```

**Step 4**: Convert back to text

```
01001000 = H
01000101 = E
01001100 = L
01001100 = L
01001111 = O
```

**Result**: "HELLO"

#### **Why It Works**

```
P XOR K = C (encryption)
C XOR K = P (decryption)

Because: (P XOR K) XOR K = P XOR (K XOR K) = P XOR 0 = P
```

#### **Security Analysis**

- **Perfect Secrecy**: If key is truly random, equal length, and used once
- **Unbreakable**: Without key, all possible plaintexts equally likely
- **Practical Issues**:
    - Key must be as long as message
    - Key distribution problem
    - Key must never be reused

#### **Limitations**

- **Key length**: Impractical for long messages
- **Key distribution**: Secure key exchange required
- **Key reuse vulnerability**: If key reused, can be broken
- **No authentication**: Doesn't verify sender identity

---

### 4. SYMMETRIC CRYPTOGRAPHY

#### **Overview**

- **Symmetric Encryption**: Same key used for encryption and decryption
- **Two Main Types**:
    1. Stream Ciphers
    2. Block Ciphers

---

### 5. STREAM CIPHERS

#### **Concept**

- Encrypts data one bit or byte at a time
- Uses keystream generated from key
- Fast and efficient for real-time data

#### **RC4 Stream Cipher**

**Characteristics**:

- Simple and fast
- Variable key size (40-2048 bits)
- Used in WEP, WPA (now deprecated due to vulnerabilities)

**How RC4 Works**:

**Step 1: Key Scheduling Algorithm (KSA)**

- Initialize state array S with values 0-255
- Permute S based on key

**Step 2: Pseudo-Random Generation Algorithm (PRGA)**

- Generate keystream bytes
- XOR keystream with plaintext

**Encryption**:

```
Plaintext XOR Keystream = Ciphertext
```

**Decryption**:

```
Ciphertext XOR Keystream = Plaintext
```

**Security Issues**:

- Key reuse vulnerabilities
- Weak keys exist
- Biases in keystream
- No longer considered secure

---

### 6. BLOCK CIPHERS

#### **Concept**

- Encrypts data in fixed-size blocks
- Common block size: 64 bits or 128 bits
- More complex than stream ciphers

#### **Feistel Cipher Structure**

**General Concept**:

- Divides plaintext block into two halves
- Processes through multiple rounds
- Each round:
    1. One half modified using round function
    2. Result XORed with other half
    3. Halves swapped

**Structure**:

```
Plaintext → [L₀|R₀]
    ↓
Round 1: L₁ = R₀, R₁ = L₀ ⊕ F(R₀, K₁)
    ↓
Round 2: L₂ = R₁, R₂ = L₁ ⊕ F(R₁, K₂)
    ↓
    ...
    ↓
Round n: Lₙ = Rₙ₋₁, Rₙ = Lₙ₋₁ ⊕ F(Rₙ₋₁, Kₙ)
    ↓
Ciphertext → [Rₙ|Lₙ]
```

**Key Properties**:

- **Self-inverting**: Same structure for encryption and decryption
- **Security**: Depends on round function F and number of rounds
- **Reversibility**: Guaranteed by structure

#### **DES (Data Encryption Standard)**

**Overview**:

- Developed by IBM in 1970s
- Adopted as US federal standard in 1977
- Block size: **64 bits**
- Key size: **56 bits** (+ 8 parity bits = 64 bits total)
- Number of rounds: **16**

**DES Structure**:

**1. Initial Permutation (IP)**

- Rearranges bits of plaintext block

**2. 16 Feistel Rounds** Each round:

- Divide block into left (L) and right (R) halves (32 bits each)
- Expand R from 32 to 48 bits
- XOR with 48-bit round key
- Pass through S-boxes (substitution)
- Permute result
- XOR with L
- Swap halves

**3. Final Permutation (FP = IP⁻¹)**

- Inverse of initial permutation

**DES Round Function F**:

```
F(R, K) = P(S(E(R) ⊕ K))
```

Where:

- **E**: Expansion (32 → 48 bits)
- **⊕**: XOR with round key K
- **S**: Substitution using S-boxes (48 → 32 bits)
- **P**: Permutation (32 bits)

**DES Key Schedule**:

- Takes 56-bit key
- Generates 16 different 48-bit round keys
- Each round uses different subkey

**DES Security Issues**:

- **56-bit key too small**: Vulnerable to brute force
- Can be broken in hours with modern hardware
- **No longer secure** for sensitive data

#### **3DES (Triple DES)**

**Motivation**: Increase DES security without designing new cipher

**Method**: Apply DES three times with different keys

**3DES-EDE (Encrypt-Decrypt-Encrypt)**:

```
Ciphertext = Eₖ₃(Dₖ₂(Eₖ₁(Plaintext)))
```

**Three Key Variants**:

1. **3DES with 3 keys** (K₁, K₂, K₃):
    
    - Effective key length: 168 bits
    - Most secure variant
2. **3DES with 2 keys** (K₁, K₃, with K₂ = K₁):
    
    - Effective key length: 112 bits
    - Common implementation
3. **3DES with 1 key** (K₁ = K₂ = K₃):
    
    - Equivalent to regular DES
    - Not recommended

**Why EDE (Encrypt-Decrypt-Encrypt)?**

- Backward compatible with DES
- If K₁ = K₂ = K₃, becomes regular DES

**Decryption**:

```
Plaintext = Dₖ₁(Eₖ₂(Dₖ₃(Ciphertext)))
```

**Security**:

- Much stronger than DES
- Still considered secure but slow
- Being replaced by AES

---

### 7. BLOCK CIPHER MODES OF OPERATION

Block ciphers need modes to encrypt messages longer than block size.

#### **ECB (Electronic Codebook) Mode**

**How It Works**:

- Divide plaintext into blocks
- Encrypt each block independently with same key
- No chaining between blocks

**Encryption**:

```
For each block Pᵢ:
Cᵢ = E(K, Pᵢ)
```

**Decryption**:

```
For each block Cᵢ:
Pᵢ = D(K, Cᵢ)
```

**Diagram**:

```
P₁ → E(K) → C₁
P₂ → E(K) → C₂
P₃ → E(K) → C₃
```

**Security Issues**:

- **Pattern preservation**: Identical plaintext blocks → identical ciphertext blocks
- **Information leakage**: Reveals patterns in data
- **Never use** (except for testing)
- Famous example: Encrypted image of penguin still shows penguin shape

#### **CBC (Cipher Block Chaining) Mode**

**How It Works**:

- Each plaintext block XORed with previous ciphertext block before encryption
- First block XORed with Initialization Vector (IV)
- Creates chaining effect

**Encryption**:

```
C₀ = IV
For each block Pᵢ:
Cᵢ = E(K, Pᵢ ⊕ Cᵢ₋₁)
```

**Decryption**:

```
C₀ = IV
For each block Cᵢ:
Pᵢ = D(K, Cᵢ) ⊕ Cᵢ₋₁
```

**Diagram**:

```
Encryption:
IV ──⊕→ E(K) → C₁ ──⊕→ E(K) → C₂
      ↑                  ↑
      P₁                 P₂

Decryption:
C₁ → D(K) ──⊕→ P₁
              ↑
              IV
C₂ → D(K) ──⊕→ P₂
              ↑
              C₁
```

**Properties**:

- **IV must be random** and unpredictable
- **IV doesn't need to be secret** but must be known to decryptor
- Errors propagate (one bit error affects two blocks)

**Information Leakage**:

- When Cᵢ == Cⱼ:
    
    ```
    E(K, Pᵢ ⊕ Cᵢ₋₁) == E(K, Pⱼ ⊕ Cⱼ₋₁)Pᵢ ⊕ Cᵢ₋₁ == Pⱼ ⊕ Cⱼ₋₁Pᵢ ⊕ Pⱼ == Cᵢ₋₁ ⊕ Cⱼ₋₁
    ```
    
- Previous ciphertext blocks reveal info about plaintext blocks
- Similar to one-time pad problem with key reuse

**Security**:

- **Use with caution**
- Subtle leakage: Attacker learns if Pᵢ = Pⱼ when Cᵢ = Cⱼ
- Vulnerable to cut-and-paste attacks

#### **CTR (Counter) Mode**

**How It Works**:

- Turns block cipher into stream cipher
- Encrypts counter values
- XOR encrypted counters with plaintext

**Encryption**:

```
For each block i:
Cᵢ = Pᵢ ⊕ E(K, nonce || counter)
```

**Decryption**:

```
For each block i:
Pᵢ = Cᵢ ⊕ E(K, nonce || counter)
```

**Diagram**:

```
nonce||ctr₁ → E(K) ──⊕→ C₁
                      ↑
                      P₁

nonce||ctr₂ → E(K) ──⊕→ C₂
                      ↑
                      P₂
```

**Properties**:

- **Nonce** (number used once) must be unique
- **Counter** increments for each block
- Encryption of each block **independent** of others
- Can be **parallelized** (unlike CBC)
- No error propagation

**Security**:

- **Modern & Efficient**
- **No pattern leakage** (with proper nonce)
- Nonce must never be reused with same key
- Otherwise, same vulnerabilities as stream cipher with key reuse

#### **Comparison of Modes**

|Mode|Pattern Leakage|Parallelizable|Error Propagation|Status|
|---|---|---|---|---|
|ECB|High (Never Use)|Yes|No|Insecure|
|CBC|Medium (Use with caution)|Decrypt only|2 blocks|Acceptable|
|CTR|Low (Recommended)|Yes|No|Secure|

**Note**: Security in all modes depends on randomness/uniqueness of IV or nonce.

---

### 8. ASYMMETRIC CRYPTOGRAPHY - KNAPSACK

#### **What is Asymmetric Cryptography?**

- Uses **two keys**:
    - **Public Key**: Encrypts data (can be shared publicly)
    - **Private Key**: Decrypts data (must be kept secret)
- **No shared secret** required between sender and receiver
- Solves key distribution problem

#### **Knapsack Cryptosystem**

- One of earliest examples of public-key cryptography
- Proposed by **Merkle and Hellman**
- Based on ideas from **Diffie and Hellman**
- Uses **superincreasing knapsack problem** to create keys
- Mathematical puzzle of finding combination of weights that sum to specific target

#### **The General Knapsack Problem**

**Problem Statement**: Given set of weights {w₀, w₁, ..., wₙ₋₁}, find binary values {a₀, a₁, ..., aₙ₋₁} ∈ {0,1} such that:

```
S = a₀·w₀ + a₁·w₁ + ... + aₙ₋₁·wₙ₋₁
```

Where:

- **S**: Target sum
- **wᵢ**: Weights
- **aᵢ**: Binary values (0 or 1) indicating whether weight is included

**General Knapsack**: NP-complete (computationally hard)

#### **Superincreasing Knapsack (SK)**

**Definition**: Special case where each weight wᵢ is **greater than sum of all previous weights**:

```
wᵢ > w₀ + w₁ + ... + wᵢ₋₁
```

**Example**:

```
[2, 3, 6, 13, 27, 57, 120, 251]

Verify:
3 > 2 ✓
6 > 2 + 3 = 5 ✓
13 > 2 + 3 + 6 = 11 ✓
27 > 2 + 3 + 6 + 13 = 24 ✓
...
```

**Key Property**: Superincreasing knapsack is **easy to solve** using greedy algorithm

#### **Solving Superincreasing Knapsack**

**Example**: Find aᵢ for S = 204 with weights [2, 3, 6, 13, 27, 57, 120, 251]

**Algorithm**:

1. Start with largest weight
2. If weight ≤ remaining sum, include it (aᵢ = 1), subtract from sum
3. If weight > remaining sum, exclude it (aᵢ = 0)
4. Move to next smaller weight
5. Repeat until sum = 0

**Solution Steps**:

```
S = 204
251 > 204 → a₇ = 0, S = 204
120 ≤ 204 → a₆ = 1, S = 204 - 120 = 84
57 ≤ 84  → a₅ = 1, S = 84 - 57 = 27
27 = 27  → a₄ = 1, S = 27 - 27 = 0
13 > 0   → a₃ = 0
6 > 0    → a₂ = 0
3 > 0    → a₁ = 0
2 > 0    → a₀ = 0

Solution: [0, 0, 0, 0, 1, 1, 1, 0]
Verification: 27 + 57 + 120 = 204 ✓
```

#### **Knapsack Cryptosystem: Key Generation**

**Private Key Components**:

1. **Superincreasing knapsack**: {w₀, w₁, ..., wₙ₋₁}
2. **Modulus n**: Where n > Σwᵢ (sum of all weights)
3. **Multiplier m**: Relatively prime to n (gcd(m, n) = 1)

**Public Key Generation**: Transform superincreasing knapsack into general knapsack:

```
For each weight wᵢ:
kᵢ = (m × wᵢ) mod n
```

Public Key: {k₀, k₁, ..., kₙ₋₁}

#### **Example: Key Generation**

**Given**:

- **Superincreasing Knapsack (SK)**: [2, 3, 6, 13, 27, 57, 120, 251]
- Sum of SK = 479
- **Choose modulus n = 491** (n > 479 ✓)
- **Choose multiplier m = 41** (gcd(41, 491) = 1 ✓)

**Private Key**:

- SK: [2, 3, 6, 13, 27, 57, 120, 251]
- n: 491
- m: 41

**Public Key Calculation**:

```
k₀ = (41 × 2) mod 491 = 82
k₁ = (41 × 3) mod 491 = 123
k₂ = (41 × 6) mod 491 = 246
k₃ = (41 × 13) mod 491 = 42
k₄ = (41 × 27) mod 491 = 125
k₅ = (41 × 57) mod 491 = 373
k₆ = (41 × 120) mod 491 = 10
k₇ = (41 × 251) mod 491 = 471
```

**Public Key**: [82, 123, 246, 42, 125, 373, 10, 471]

#### **Knapsack Encryption - HOW TO ENCODE**

**Message to Encrypt**: "00001110" (binary)

**Step 1**: Convert message to bit pattern

```
Message: 00001110
Positions: 0  1  2  3  4  5  6  7
Bits:      0  0  0  0  1  1  1  0
```

**Step 2**: Select corresponding public key values where bit = 1

```
Position 4: k₄ = 125
Position 5: k₅ = 373
Position 6: k₆ = 10
```

**Step 3**: Compute ciphertext (sum of selected values)

```
c = 125 + 373 + 10 = 508
```

**Ciphertext**: 508

**General Formula**:

```
c = Σ(aᵢ × kᵢ) where aᵢ is message bit
c = a₀·k₀ + a₁·k₁ + ... + aₙ₋₁·kₙ₋₁
```

#### **Knapsack Decryption - HOW TO DECODE**

**Ciphertext**: 508

**Step 1**: Compute modular inverse of m Find m⁻¹ such that: (m × m⁻¹) mod n = 1

```
(41 × m⁻¹) mod 491 = 1
m⁻¹ = 12  (can be found using Extended Euclidean Algorithm)

Verify: (41 × 12) mod 491 = 492 mod 491 = 1 ✓
```

**Step 2**: Multiply ciphertext by modular inverse

```
S' = (c × m⁻¹) mod n
S' = (508 × 12) mod 491
S' = 6096 mod 491
S' = 204
```

**Step 3**: Solve superincreasing knapsack problem Now solve for S' = 204 using private key SK: [2, 3, 6, 13, 27, 57, 120, 251]

```
204 - 120 = 84  → a₆ = 1
84 - 57 = 27    → a₅ = 1
27 - 27 = 0     → a₄ = 1
Others = 0

Solution: [0, 0, 0, 0, 1, 1, 1, 0]
```

**Step 4**: Reconstruct binary message

```
Decrypted message: 00001110 ✓
```

**Why This Works**:

```
c = Σ(aᵢ × kᵢ)
c = Σ(aᵢ × (m × wᵢ mod n))

c × m⁻¹ mod n = Σ(aᵢ × wᵢ × m × m⁻¹) mod n
                = Σ(aᵢ × wᵢ) mod n
                = S' (which is superincreasing knapsack problem)
```

#### **Complete Example Walkthrough**

**Encryption**:

```
Message: 00001110
Public Key: [82, 123, 246, 42, 125, 373, 10, 471]

Selected:
Position 4: 125
Position 5: 373
Position 6: 10

Ciphertext = 508
```

**Decryption**:

```
Ciphertext: 508
Private Key:
- SK: [2, 3, 6, 13, 27, 57, 120, 251]
- n: 491
- m: 41
- m⁻¹: 12

Step 1: 508 × 12 mod 491 = 204
Step 2: Solve SK for 204
        204 = 120 + 57 + 27
        Positions: 6, 5, 4
        Binary: 00001110

Decrypted message: 00001110 ✓
```

#### **Security Issues**

**Vulnerabilities**:

- **Lattice-based attacks** (discovered 1985)
- Can break even with large key sizes
- **No longer considered secure** for modern cryptography

**Comparison**:

- Much **less secure than RSA** and other modern asymmetric systems
- Primarily of historical interest
- Demonstrates concepts of public-key cryptography

**Why It Failed**:

- Transformation from superincreasing to general knapsack not strong enough
- Lattice reduction algorithms can recover private key from public key
- Structure of superincreasing sequence provides weakness

---

## SUMMARY & KEY TAKEAWAYS

### Operating Systems

**Process Management**:

- Processes are programs in execution with their own memory space
- PCB stores process state for context switching
- Process states: New, Ready, Running, Blocked, Terminated
- Context switching enables multitasking

**Threading**:

- Threads are lightweight execution units within processes
- Share process resources but have independent execution
- Models: Many-to-One, One-to-One, Many-to-Many
- Thread pools optimize thread reuse

### Cryptography

**Classical Ciphers**:

- Double Transposition: Matrix-based permutation cipher
- Vulnerable to frequency analysis and pattern detection

**Perfect Secrecy**:

- One-Time Pad achieves perfect secrecy
- Key must be random, same length as message, used once
- XOR operation for encryption/decryption

**Symmetric Cryptography**:

- Stream Ciphers (RC4): Encrypt bit-by-bit using keystream
- Block Ciphers (DES, 3DES): Encrypt fixed-size blocks
- Modes: ECB (insecure), CBC (careful use), CTR (recommended)

**Asymmetric Cryptography**:

- Knapsack: Public key derived from superincreasing sequence
- Private key uses easy superincreasing problem
- Historically important but now broken

---

## IMPORTANT FORMULAS & ALGORITHMS

### Cryptography Formulas

**One-Time Pad**:

```
Encryption: C = P ⊕ K
Decryption: P = C ⊕ K
```

**Block Cipher Modes**:

```
ECB: Cᵢ = E(K, Pᵢ)
CBC: Cᵢ = E(K, Pᵢ ⊕ Cᵢ₋₁)
CTR: Cᵢ = Pᵢ ⊕ E(K, nonce||counter)
```

**Knapsack**:

```
Public Key: kᵢ = (m × wᵢ) mod n
Encryption: c = Σ(aᵢ × kᵢ)
Decryption: S' = (c × m⁻¹) mod n
```

**Perfect Secrecy**:

```
P(m|c) = P(m)
```

---

_End of Comprehensive Notes_