# Detailed Notes on Hashing - Information Security

## 1. Introduction to Cryptographic Hash Functions

### Definition and Core Properties

A cryptographic hash function `h` is a mathematical function with these characteristics:

**Functional Properties:**

- **Arbitrary input length**: Can accept any size message
- **Fixed output length**: Always produces n bits (e.g., 128, 256, 512 bits)
- **Deterministic**: Same input always produces same output
- **Efficient computation**: Fast to calculate

**Security Properties:**

- **Preimage resistance**: Given hash value y = h(x), computationally infeasible to find x
- **Second-preimage resistance**: Given x₁, infeasible to find different x₂ where h(x₁) = h(x₂)
- **Collision resistance**: Infeasible to find any two distinct inputs x₁, x₂ such that h(x₁) = h(x₂)

**Key Distinction**: Hashing provides **integrity** (detecting changes), not **confidentiality** (hiding content)

---

## 2. Early Hash Attempts - Why Simple Methods Fail

### Try 1: Simple Addition (Checksum)

**Method**: h(x) = Σxᵢ mod 256

**How it works:**

1. Treat message as sequence of bytes
2. Add all bytes together
3. Take result modulo 256 (produces 1-byte output)

**Pros:**

- ✓ Compresses any file to 1 byte
- ✓ Very fast computation
- ✓ Some preimage resistance (given hash 120, can't easily reverse)

**Critical Flaw - No Collision Resistance:**

- Addition is **commutative**: A + B = B + A
- Anagrams produce identical hashes
- Example: "intern copy" and "inept crony" hash to same value
- Reordering bytes doesn't change sum
- **Conclusion**: Trivial to create collisions

---

### Try 2: Weighted Addition

**Method**: h(x) = Σ(i × xᵢ) mod 256

**How it works:**

1. Multiply each byte by its position (index)
2. Sum all products
3. Take result modulo 256

**Example calculation:** For message "Hi":

- 'H' = ASCII 72, position 1: 1 × 72 = 72
- 'i' = ASCII 105, position 2: 2 × 105 = 210
- Total: 72 + 210 = 282
- Hash: 282 mod 256 = 26

**Pros:**

- ✓ Retains speed and compression
- ✓ Prevents anagram collisions (position matters)
- ✓ "intern copy" ≠ "inept crony"

**Critical Flaw - Second Preimage Attacks:**

**Collision Example: "@0" vs ">1"**

For "@0":

- '@' = ASCII 64, position 1: 1 × 64 = 64
- '0' = ASCII 48, position 2: 2 × 48 = 96
- Total: 64 + 96 = 160

For ">1":

- '>' = ASCII 62, position 1: 1 × 62 = 62
- '1' = ASCII 49, position 2: 2 × 49 = 98
- Total: 62 + 98 = 160

**Both hash to 160!**

**Why this fails:**

- Can solve algebraically for collisions
- Given target hash, can construct input
- **Linearity** makes finding second preimages easy
- Not cryptographically secure

---

## 3. The Birthday Paradox and Collision Probability

**Birthday Paradox**: In a room of 23 people, 50% probability two share a birthday

**Applied to hashing:**

- For n-bit hash output: 2ⁿ possible values
- To find collision: need approximately √(2ⁿ) = 2^(n/2) attempts
- This is **much less** than 2ⁿ

**Examples:**

- 128-bit hash (MD5): expect collision after ~2⁶⁴ attempts
- 160-bit hash (SHA-1): expect collision after ~2⁸⁰ attempts
- 256-bit hash (SHA-256): expect collision after ~2¹²⁸ attempts

**Implication**: Hash output must be twice as long as desired security level

---

## 4. Merkle-Damgård Construction

### Overview

A general framework for building hash functions from a **compression function**. Used by MD5, SHA-1, SHA-2, Tiger.

### Architecture Components

**1. Initialization Vector (IV)**

- Fixed starting state
- Example values (constants chosen for security properties)

**2. Compression Function F**

- Takes: Previous state + Current message block
- Outputs: New state
- Core cryptographic primitive

**3. Message Blocks**

- Message divided into fixed-size blocks
- Padding added to last block

**4. Final State = Hash**

- Output after processing all blocks

### Process Flow

```
State₀ = IV (fixed initialization vector)
State₁ = F(State₀, Block₁)
State₂ = F(State₁, Block₂)
...
Stateₙ = F(Stateₙ₋₁, Blockₙ)
Hash = Stateₙ
```

**Mathematical notation:**

```
h(M) = F(F(F(IV, B₁), B₂), ..., Bₙ)
```

### Key Insight - Internal State Exposure

**Critical vulnerability:**

- The output after processing some blocks **IS the internal state**
- Not just a digest - it's the actual working state

**Length Extension Attack:**

If you know h(K,M) where K is secret prefix:

1. **Normal hashing**: h(K, M) = F(F(Init, K), M)
2. **Output** = State after M
3. **Attacker can compute**: h(K, M, X) = F(h(K,M), X)
    - Uses h(K,M) as new IV
    - Appends arbitrary X
    - **Never needed to know K!**

**Example Attack:**

```
Normal: h(K, M) = State_K,M
Trudy: h(K, M, X) = F(State_K,M, X)
```

Trudy computes valid hash for K||M||X without knowing K!

**Why this matters:**

- Breaks naive MAC construction: h(key||message)
- This is why **HMAC** was invented (uses nested hashing)

---

## 5. Tiger Hash Function - Detailed Breakdown

### Overview

- Designed 1995 by Anderson & Biham
- **Input**: 512-bit blocks
- **Output**: 192-bit hash (3 × 64-bit words)
- **Optimized for**: 64-bit processors
- **Structure**: Modeled after block ciphers

---

### Tiger Components

#### A. Internal State

**Three 64-bit registers: a, b, c**

Initial values (constants in hex):

- a = 0x0123456789ABCDEF
- b = 0xFEDCBA9876543210
- c = 0xF096A5B4C3B2E187

These change as message blocks are processed.

---

#### B. S-Boxes (Substitution Boxes)

**Purpose**: Introduce non-linearity (prevent algebraic attacks)

**Structure:**

- **4 S-boxes**: t₁, t₂, t₃, t₄
- **256 entries each** (index 0-255)
- **64-bit output per entry**
- **Total memory**: 4 × 256 × 64 bits = 8KB

**How S-box lookup works:**

Example with c = 0x42 (decimal 66):

1. Extract byte: c₁ = 0x42
2. Look up in t₄: t₄[66] = 0x1C2D3E4F5A6B7C8D
3. Use this 64-bit value in calculation

**S-box generation:**

- Values are **cryptographically random**
- Precomputed and fixed
- Designed so changing 1 input bit changes ~half output bits (avalanche effect)

---

#### C. Processing Rounds

**Per 512-bit block:**

1. Split into **8 words** (w₀...w₇), each 64 bits
2. Run **3 passes**: F5, F7, F9 (names from multipliers)
3. Each pass has **8 rounds** (one per word)
4. **Total**: 24 rounds per block

---

### Tiger Round Function - Detailed Steps

**Input to round i:**

- Current state: a, b, c
- Message word: wᵢ

**Step-by-step execution:**

**Step 1: XOR word into c**

```
c = c ⊕ wᵢ
```

Injects message into state.

**Step 2: Split c into bytes**

```
c = [c₀, c₁, c₂, c₃, c₄, c₅, c₆, c₇]  (8 bytes)
```

**Step 3: Compute even(c) - for updating a**

```
even(c) = t₁[c₀] ⊕ t₂[c₂] ⊕ t₃[c₄] ⊕ t₄[c₆]
```

Uses bytes at even positions (0,2,4,6).

**Step 4: Compute odd(c) - for updating b**

```
odd(c) = t₄[c₁] ⊕ t₃[c₃] ⊕ t₂[c₅] ⊕ t₁[c₇]
```

Uses bytes at odd positions (1,3,5,7).

**Step 5: Update a**

```
a = a - even(c)
```

Subtract (modulo 2⁶⁴).

**Step 6: Update b**

```
b = b + odd(c)
```

Add (modulo 2⁶⁴).

**Step 7: Multiply b**

```
b = b × m  (where m = 5, 7, or 9 depending on pass)
```

- Pass 1 (F5): multiply by 5
- Pass 2 (F7): multiply by 7
- Pass 3 (F9): multiply by 9

Multiplication adds non-linearity.

**Round output**: Updated (a, b, c) → input for next round

---

### Tiger Key Schedule

**Purpose**: Prevent sparse inputs from causing weak mixing

**When**: Between passes (after F5, before F7; after F7, before F9)

**How it works**: Scrambles the 8 message words (w₀...w₇)

**Operations** (16 transformations):

```
w₀ = w₀ - (w₇ ⊕ 0xa5a5a5a5a5a5a5a5)
w₁ = w₁ ⊕ w₀
w₂ = w₂ + w₁
w₃ = w₃ - (w₂ ⊕ (~w₁ << 19))
w₄ = w₄ ⊕ w₃
w₅ = w₅ + w₄
w₆ = w₆ - (w₅ ⊕ (~w₄ >> 23))
w₇ = w₇ ⊕ w₆
w₀ = w₀ + w₇
w₁ = w₁ - (w₀ ⊕ (~w₇ << 19))
w₂ = w₂ ⊕ w₁
w₃ = w₃ + w₂
w₄ = w₄ - (w₃ ⊕ (~w₂ >> 23))
w₅ = w₅ ⊕ w₄
w₆ = w₆ + w₅
w₇ = w₇ - (w₆ ⊕ 0x0123456789abcdef)
```

**Constants used:**

- 0xa5a5a5a5a5a5a5a5 (alternating bit pattern)
- 0x0123456789abcdef (counting pattern)

**Why different operations?**

- Mix of XOR (⊕), addition (+), subtraction (-)
- Bit shifts (<< >>) with NOT (~)
- Creates dependency between all words
- Each output word depends on multiple input words

---

### Tiger Feedforward

**Purpose**: Prevent attacks that undo the compression function

**After processing each block:**

**Save initial state:**

```
aa = a (before processing)
bb = b
cc = c
```

**After 3 passes:**

```
a' = result_a
b' = result_b  
c' = result_c
```

**Feedforward operation:**

```
a = a' ⊕ aa  (XOR with saved a)
b = b' - bb  (Subtract saved b)
c = c' + cc  (Add saved c)
```

**Why different operations?**

- XOR, subtraction, addition: prevents simple reversibility
- Even if attacker finds a', they can't easily find original message

**Final hash** = (a, b, c) after processing all blocks = 192 bits total

---

## 6. Message Authentication Codes (MAC)

### Purpose

Provide **authenticity** and **integrity**, not confidentiality:

- ✓ Confirms sender identity
- ✓ Detects message tampering
- ✗ Does NOT hide message content

---

### CBC-MAC (Cipher Block Chaining MAC)

**Using block cipher in CBC mode for integrity:**

```
C₀ = E(M₀ ⊕ IV, K)
C₁ = E(M₁ ⊕ C₀, K)
...
Cₙ₋₁ = E(Mₙ₋₁ ⊕ Cₙ₋₂, K)

MAC = Cₙ₋₁  (final ciphertext block = "CBC residue")
```

**Discard all intermediate ciphertext blocks** - only keep final one.

**Verification**: Receiver recomputes MAC with same key, compares.

---

### Why NOT Just Hash the Message?

**Naive approach**: Send (M, h(M))

**Attack:**

```
1. Trudy intercepts: M = "Transfer $100", h(M) = 0x3A4F8B2C
2. Trudy modifies: M' = "Transfer $900"
3. Trudy computes: h(M') = 0x8D7E2F1A
4. Trudy sends: (M', h(M'))
5. Bob receives and verifies: h(received M') matches? ✓ YES!
```

**Problem**: Anyone can compute hash - no secret involved!

**Solution**: Involve a **secret key K** that only Alice and Bob know.

---

### Two Naive MAC Attempts

#### Attempt 1: Prepend Key - h(K, M)

**Method:**

```
h(K, M) = F(F(Init, K), M)
```

**Vulnerability: Length Extension Attack**

Given h(K, M):

```
1. Trudy intercepts: M, h(K,M)
2. Trudy wants to append X
3. Trudy computes: h(K, M, X) = F(h(K,M), X)
   - Uses h(K,M) as starting state!
   - Never needed to know K
4. Sends: (M||X, computed hash)
5. Bob verifies: h(K, M||X) - matches! ✓
```

**Why it works**: h(K,M) becomes the "key" for extending.

---

#### Attempt 2: Append Key - h(M, K)

**Method:**

```
h(M, K) = F(F(Init, M), K)
```

**Better**: Resists length extension (attacker doesn't know final state).

**Vulnerability: Collision attacks**

If hash function has **collisions** (h(M₁) = h(M₂)):

```
Internal state after M₁ = Internal state after M₂

Therefore:
h(M₁, K) = F(State_M1, K) = F(State_M2, K) = h(M₂, K)

If attacker finds M₁ ≠ M₂ where h(M₁) = h(M₂):
- MAC for M₁ with key K = MAC for M₂ with same key K
```

**Problem**: Vulnerable if underlying hash has collision weaknesses.

---

### HMAC (RFC 2104) - The Correct Solution

**Purpose**: Securely combine hash function with secret key.

**Key principle**: **Nested hashing** prevents both length extension and collision attacks.

---

#### HMAC Construction

**Given:**

- Hash function h
- Block size B (e.g., 64 bytes for MD5/SHA-1)
- Secret key K

**Constants:**

- ipad = 0x36 repeated B times (00110110 in binary)
- opad = 0x5C repeated B times (01011100 in binary)

**Why these values?**

- Good Hamming distance (many bit differences)
- ~50% ones, ~50% zeros (good mixing)

---

#### HMAC Algorithm - Step by Step

**Step 1: Key preparation**

```
If len(K) > B:
    K = h(K)  (hash the key)
If len(K) < B:
    K = K || 0x00...00  (pad with zeros to B bytes)
```

**Step 2: Compute inner hash**

```
K_ipad = K ⊕ ipad  (XOR key with ipad)
inner_input = K_ipad || M  (concatenate with message)
inner_hash = h(inner_input)
```

**Step 3: Compute outer hash**

```
K_opad = K ⊕ opad  (XOR key with opad)
outer_input = K_opad || inner_hash
HMAC = h(outer_input)
```

**Complete formula:**

```
HMAC(K, M) = h((K ⊕ opad) || h((K ⊕ ipad) || M))
```

---

#### Why HMAC is Secure

**Against length extension:**

```
Attacker knows: M, HMAC(K,M)
Wants to compute: HMAC(K, M||X)

Inner hash: h((K ⊕ ipad) || M)
Outer hash: h((K ⊕ opad) || inner_hash)

To extend, attacker needs:
- State after (K ⊕ ipad) || M - but doesn't have this!
- Final HMAC is hash of (K ⊕ opad) || something
- Can't use HMAC as IV because outer key is different
```

**Against collision attacks:**

```
Even if h(M₁) = h(M₂):
- Inner hash includes K ⊕ ipad
- Collision would need h((K⊕ipad)||M₁) = h((K⊕ipad)||M₂)
- Without knowing K, can't construct such collision
- Outer hash adds second layer with different key derivation
```

**Security properties:**

- Preimage resistant (can't find M from HMAC)
- Second-preimage resistant (can't find M' giving same HMAC)
- Collision resistant (can't find M₁, M₂ with same HMAC)

---

#### HMAC Performance

**Overhead:**

- Inner hash: Process entire message + 1 block for key
- Outer hash: Process 1 block (just inner hash output)
- **Total**: ~2 hash operations worth of work
- Minimal compared to message processing

---

## 7. CRC (Cyclic Redundancy Check)

### Purpose

Detect **accidental** errors (noise, interference), NOT malicious tampering.

**Used in:**

- Ethernet frames
- ZIP files
- PNG images
- Storage devices

### Why CRC is NOT Cryptographic

**Fatal flaw**: It's **linear** (based purely on XOR operations).

---

### CRC Algorithm - Polynomial Division

**Key concept**: Treat data as coefficients of polynomial, divide by generator polynomial.

#### Components

**1. Divisor (Generator Polynomial)**

- Fixed polynomial
- Example: 10011 (5 bits)
- Represents: x⁴ + x + 1
- Ethernet uses CRC-32: x³² + x²⁶ + x²³ + ... + x + 1

**2. Dividend**

- Message data
- Example: 10101011 (8 bits)

**3. Appended zeros**

- Add (n-1) zeros to message, where n = divisor length
- Example: divisor = 5 bits → append 4 zeros
- Final dividend: 101010110000

---

#### CRC Computation Example

**Given:**

- Message: 10101011
- Divisor: 10011 (5 bits, so append 4 zeros)
- Dividend: 101010110000

**Process**: XOR-based long division

```
Step 1:
Current: 10101 (first 5 bits)
XOR with: 10011 (divisor)
Result: 00110

Step 2:
Bring down: 0 → 01100
MSB = 0, skip XOR

Step 3:
Bring down: 1 → 11001
XOR with: 10011
Result: 01010

Step 4:
Bring down: 0 → 10101
XOR with: 10011
Result: 00110

Step 5:
Bring down: 1 → 01100
MSB = 0, skip

Step 6:
Bring down: 0 → 11000
XOR with: 10011
Result: 01011

Step 7:
Bring down: 0 → 10110
XOR with: 10011
Result: 00101

Step 8:
Bring down: 0 → 01010
MSB = 0, done

Final remainder: 01010
CRC = 1010 (drop leading zero)
```

**Key operations:**

- When MSB = 1: XOR with divisor
- When MSB = 0: Skip (or XOR with zeros, same result)
- Bring down next bit and repeat

---

#### CRC Verification

**Transmit**: Original message + CRC Example: 101010111010

**Receiver:**

1. Performs same division on received data
2. Remainder should be 0 if no errors occurred

**Mathematical property:**

```
(data + zeros) ⊕ divisor = CRC
→ (data + CRC) ⊕ divisor = 0
```

---

### Why CRC Fails for Security

#### Linearity Makes Collisions Easy

**Problem**: CRC is purely XOR-based operations.

**Creating intentional collision:**

```
Original: 101010111010, CRC = 1010

1. Note intermediate remainder before final bits
   Example: remainder = 110 at step 6

2. Once remainder = 110, final CRC will always be 1010
   (determined by last 4 bits)

3. Change earlier bits arbitrarily
   As long as you reach remainder = 110 again,
   CRC will still be 1010

4. Solve linear equations to find which bits to change
```

**Example modification:**

```
Original:  101010111010 → CRC = 1010
Modified:  010.....1010 → CRC = 1010 (can force same CRC)
```

**Why this works:**

- CRC operations are **linear transformations**
- Can solve: "What input X gives remainder Y?"
- Cryptographic hashes need **non-linear** operations (S-boxes, multiplication)

---

### CRC vs Cryptographic Hash

|Property|CRC|Cryptographic Hash|
|---|---|---|
|Linearity|Linear (XOR only)|Non-linear (S-boxes, modular arithmetic)|
|Intentional collisions|Easy (solve equations)|Infeasible (requires 2^(n/2) work)|
|Purpose|Detect accidental errors|Detect malicious tampering|
|Speed|Very fast|Slower (more complex operations)|
|Security|None|High|

---

## 8. MD5 and SHA-1 - Broken Hash Functions

### MD5 (Message Digest 5)

**Specifications:**

- Output: 128 bits
- Block size: 512 bits
- Designed: 1991 by Ron Rivest
- Uses Merkle-Damgård construction

**Timeline of breaks:**

- **2004**: First collisions found (Wang et al.)
- **2007**: Chosen-prefix collisions (Stevens et al.)
- **2008**: Collision in seconds on standard PC
- **Status**: Completely broken

**Real-world impact:**

- Flame malware (2012) used MD5 collision to forge Microsoft certificate
- Should be avoided entirely

---

### SHA-1 (Secure Hash Algorithm 1)

**Specifications:**

- Output: 160 bits
- Block size: 512 bits
- Designed: 1995 by NSA
- Uses Merkle-Damgård construction

**Timeline of breaks:**

- **2005**: Theoretical collision in 2⁶⁹ operations (Wang et al.)
- **2012**: Improved to 2⁶⁰ operations (Stevens)
- **2017**: First practical collision - SHAttered attack
- **Status**: Deprecated, collisions feasible

---

### Breaking SHA-1: Cost Analysis

#### Theoretical Attack (Stevens, 2012)

**Complexity**: 2⁶⁰ SHA-1 operations

**Step 1: Cost per operation**

```
1 SHA-1 operation ≈ 2¹⁴ CPU cycles (E-BASH benchmark)
```

**Step 2: Total CPU cycles**

```
2¹⁴ × 2⁶⁰ = 2⁷⁴ cycles
```

**Step 3: Server capability (2016)**

```
High-end server: 2³⁸ cycles/second
Server-year: 2³⁸ × 2²⁵ (seconds/year) = 2⁶³ cycles/year
```

**Step 4: Required server-years**

```
2⁷⁴ / 2⁶³ = 2¹¹ = 2,048 server-years
```

**What this means:**

- Rent 2,048 servers for 1 year, OR
- Rent 1 server for 2,048 years, OR
- Rent 4,096 servers for 6 months

---

#### Moore's Law Impact

**Computing power doubles every 18 months**

```
Year 2016: 2⁶³ cycles/year per server → Need 2¹¹ servers
Year 2019: 2⁶⁵ cycles/year per server → Need 2⁹ servers (512)
Year 2022: 2⁶⁷ cycles/year per server → Need 2⁷ servers (128)
```

**Cost implications** (assuming €250/server-year):

```
2016: 2¹¹ × 2⁸ = 2¹⁹ = €524,288
2019: 2⁹ × 2⁸ = 2¹⁷ = €131,072
2022: 2⁷ × 2⁸ = 2¹⁵ = €32,768
```

**Attack becomes 16× cheaper every 6 years!**

---

#### SHAttered Attack (2017)

**Real-world collision by Google & CWI:**

- Two different PDFs with same SHA-1 hash
- Used ≈ 2⁶³ operations (not full 2⁶⁰)
- Estimated cloud cost: ~$110,000
- Confirmed SHA-1 practically broken

**Impact:**

- Git switched from SHA-1 to SHA-256
- Certificate authorities stopped issuing SHA-1 certificates
- NIST officially deprecated SHA-1

---

### Lessons from SHA-1

**1. Security has expiration date**

- Algorithms don't suddenly break
- Attacks gradually become affordable

**2. Moore's Law helps attackers**

- Same attack becomes cheaper exponentially
- Plan for 20+ years of security

**3. Migrate early**

- NIST deprecated SHA-1 in 2011
- Actual break came 2017
- 6-year warning period

**4. Current recommendations**

- **Minimum**: SHA-256 (256-bit output)
- **Better**: SHA-3 (different construction, not Merkle-Damgård)
- **Future-proof**: Consider SHA-512

---

## 9. Secret Sharing (Shamir's Secret Sharing)

### Problem

How to split secret so:

- No single person knows complete secret
- Multiple people together can recover it
- Any fewer people learn nothing

---

### Mathematical Foundation

**Key principle**: Polynomial of degree n requires n+1 points to reconstruct.

#### Example: Straight Line (Degree 1)

**Equation**: y = ax + S

**Components:**

- S = secret (y-intercept, value at x=0)
- a = random slope
- Two points determine unique line

**Visual:**

```
    y
    |        ● (x₂, y₂)
    |      /
    |    /
  S |  ● (x₁, y₁)
    | /
    |/_____________ x
    0
```

**Recovering S from two points:**

```
Given: (x₁, y₁) and (x₂, y₂)

Slope: a = (y₂ - y₁) / (x₂ - x₁)
Intercept: S = y₁ - a × x₁

Or directly:
S = y₁ - x₁ × [(y₂ - y₁) / (x₂ - x₁)]
```

---

### (t, n) Threshold Scheme

**Goal**: Any t out of n people can recover secret.

#### Setup

**1. Choose polynomial of degree t-1:**

```
y = a₀ + a₁x + a₂x² + ... + aₜ₋₁xᵗ⁻¹
```

**2. Set secret:**

```
a₀ = S (the secret)
```

**3. Choose random coefficients:**

```
a₁, a₂, ..., aₜ₋₁ = random values
```

**4. Generate n shares:**

```
For each person i (i = 1 to n):
    Choose distinct xᵢ
    Compute yᵢ = a₀ + a₁xᵢ + a₂xᵢ² + ... + aₜ₋₁xᵢᵗ⁻¹
    Give person i the point (xᵢ, yᵢ)
```

---

#### Example: 2-out-of-3 Scheme

**Secret**: S = 42

**Setup:**

```
Degree t-1 = 1 (straight line)
y = a₀ + a₁x
a₀ = 42 (secret)
a₁ = 17 (random)

Polynomial: y = 42 + 17x
```

**Generate shares:**

```
Alice: x₁ = 1 → y₁ = 42 + 17(1) = 59  → (1, 59)
Bob:   x₂ = 2 → y₂ = 42 + 17(2) = 76  → (2, 76)
Carol: x₃ = 3 → y₃ = 42 + 17(3) = 93  → (3, 93)
```

**Recovery scenarios:**

**Alice + Bob:**

```
Points: (1, 59), (2, 76)
Slope: (76-59)/(2-1) = 17
Intercept: 59 - 17(1) = 42 ✓
```

**Bob + Carol:**

```
Points: (2, 76), (3, 93)
Slope: (93-76)/(3-2) = 17
Intercept: 76 - 17(2) = 42 ✓
```

**Alice alone:**

```
Infinite lines through (1, 59)
Cannot determine unique intercept ✗
```

---

### Security Properties

**1. Perfect secrecy with t-1 shares:**

```
With t-1 points, every possible secret is equally likely
No information leaked about actual secret
```

**2. Any t shares reconstruct:**

```
t points → unique polynomial of degree t-1
Evaluate at x=0 → reveals a₀ = S
```

**3. Lagrange interpolation:** For t points (x₁,y₁), ..., (xₜ,yₜ):

```
S = Σᵢ yᵢ × Πⱼ≠ᵢ (-xⱼ)/(xᵢ-xⱼ)
```

(Formula for recovering secret from shares)

---

### Real-World Applications

#### Key Escrow

**Problem**: Trust no single entity with master key.

**Solution:**

```
Split master key into n shares
Distribute to different escrow agents:
  - Court
  - Government agency  
  - Independent auditor
  - Company officers

Require t agents to recover key (e.g., any 3 of 5)
```

**Example - Corporate password vault:**

```
Company master key split 3-of-5:
- CEO
- CTO
- CFO  
- Lead Security Engineer
- External Auditor

Any 3 can recover if emergency
Prevents single point of failure
```

#### Cryptocurrency Wallets

**Multisignature wallets:**

```
Bitcoin wallet requiring 2-of-3 signatures:
- Your laptop
- Your phone
- Hardware wallet

Lose one device? Still have access
Thief steals one? Cannot access funds
```

---

## 10. Steganography

### Definition

Hiding secret messages within innocent-looking data.

**Key difference from encryption:**

- Encryption: Everyone knows secret exists, can't read it
- Steganography: No one knows secret exists

---

### Common Techniques

#### 1. Image LSB (Least Significant Bit)

**How it works:**

**Color representation**: Each pixel = (R, G, B), each 0-255

Example pixel: (203, 158, 97)

```
R: 11001011
G: 10011110  
B: 01100001
```

**LSB replacement:**

```
Secret message: "Hi" = 01001000 01101001 (ASCII)

Modify LSBs:
R: 1100101[0] → 11001010 (203 → 202)
G: 1001111[1] → 10011111 (158 → 159)
B: 0110000[0] → 01100000 (97 → 96)
...continue for remaining bits
```

**Result**: Color change imperceptible to human eye.

**Capacity**: 3 bits per pixel (1 per color channel)

---

#### 2. File Header Unused Bits

**Many file formats have reserved/unused fields:**

```
Example: BMP file header has padding bytes
Insert secret data in padding
File still validates, viewers ignore padding
```

---

#### 3. Whitespace Encoding

**In text documents:**

```
Use spaces vs tabs to encode binary:
Space = 0, Tab = 1

Normal text: "Hello  World" (2 spaces)
Hidden: "Hello[space][tab]World" = binary 01
```

---

#### 4. HTML Color Codes (from course material)

**Slight color variations encode data:**

```
#FF0000 (pure red) vs #FF0001 (imperceptibly different)
Modify least significant hex digits
```

---

### Why Steganography is Weak

#### Kerckhoffs' Principle Violation

**Principle**: Security should depend only on key, not algorithm secrecy.

**Steganography problem:**

```
Security depends on:
1. Method being secret (which LSB, which bits)
2. Attacker not knowing stego is present

If method discovered → all messages compromised
```

---

#### Attacks

**1. Collusion attack:**

```
Obtain multiple versions of same "cover" data
Compare differences
Differences reveal hidden message

Example:
Image A: Pixel (203, 158, 97)
Image B: Pixel (202, 159, 96)
LSBs changed → message present!
```

**2. Statistical analysis:**

```
Natural images have certain statistical properties:
- LSB should be ~50% 0s, 50% 1s (natural randomness)
- Hidden message may skew this distribution

Chi-square test detects anomalies
```

**3. Known stego attack:**

```
If attacker knows method used:
- Extract LSBs
- Reveal complete message
- No cryptographic protection
```

---

### Steganography vs Cryptography

|Aspect|Steganography|Cryptography|
|---|---|---|
|Goal|Hide existence|Hide content|
|Security basis|Secrecy of method|Secrecy of key|
|Detection|Statistical analysis|N/A (visible)|
|Standards|None (by design)|Public (AES, RSA, etc.)|
|Strength|Weak if discovered|Strong even if known|

**Best practice**: Encrypt first, then hide (cryptography + steganography)

---

## 11. Email Security (or Lack Thereof)

### SMTP - Designed Without Security

**SMTP (Simple Mail Transfer Protocol) - RFC 5321**

- Created: 1982 (early internet, trusted environment)
- Communication: **Plain text** (no encryption)
- Authentication: **None** (anyone can claim to be anyone)

---

### Email Delivery Architecture

**Components:**

**MUA (Mail User Agent):**

- User's email client
- Examples: Outlook, Thunderbird, Gmail web interface

**MTA (Mail Transfer Agent):**

- Mail server
- Examples: Sendmail, Postfix, Exchange

**Flow:**

```
Sender's MUA → Outgoing MTA → Internet → Incoming MTA → Recipient's MUA
```

**Problem**: MTAs don't verify sender identity!

---

### Email Spoofing - Trivially Easy

#### Manual SMTP Session

**Connect directly to mail server:**

```bash
$ telnet mx-1.example.com 25
```

**Server response:**

```
220 mx-1.example.com ESMTP
```

**Identify yourself (anything accepted):**

```
HELO fake-domain.com
250 mx-1.example.com Hello fake-domain.com
```

**Set sender (any address):**

```
MAIL FROM: <president@whitehouse.gov>
250 OK
```

**Set recipient:**

```
RCPT TO: <victim@example.com>
250 OK
```

**Send message:**

```
DATA
354 Enter mail, end with "." on a line by itself
From: president@whitehouse.gov
To: victim@example.com  
Subject: URGENT

This message appears to come from the President!
.
250 OK: queued
```

**Result**: Victim receives email appearing to be from White House!

---

### Why This Works

**No verification at SMTP level:**

```
1. MAIL FROM: Server doesn't verify you own this address
2. From: header - Completely separate, anyone can set
3. No cryptographic signatures required
4. Server happily forwards
```

**Visible in email headers:**

```
Received: from [unknown] (actual-attacker-ip.com)
    by mx-1.example.com
```

But most users never check headers!

---

### Modern Defenses

#### SPF (Sender Policy Framework)

**Purpose**: Verify email comes from authorized server.

**How it works:**

**1. Domain publishes SPF record in DNS:**

```
example.com TXT: "v=spf1 ip4:203.0.113.0/24 -all"
```

Meaning: "Only servers at 203.0.113.0/24 can send mail for example.com"

**2. Receiving server checks:**

```
Email claims: from user@example.com
Actually sent from: 198.51.100.50

Look up example.com SPF record
Check if 198.51.100.50 is authorized
If not → FAIL
```

**Limitation:**

- Only checks "envelope sender" (MAIL FROM command)
- Doesn't verify visible From: header
- Attacker can set different envelope/header addresses

---

#### DKIM (DomainKeys Identified Mail)

**Purpose**: Cryptographically sign emails.

**How it works:**

**1. Sending domain has key pair:**

```
Private key: Kept secret on mail server
Public key: Published in DNS
```

**2. Sending server signs email:**

```
Compute hash of headers + body
Sign hash with private key
Add DKIM-Signature header to email
```

**Example signature header:**

```
DKIM-Signature: v=1; a=rsa-sha256; d=example.com; s=selector1;
    h=from:to:subject:date; bh=...; b=...
```

**3. Receiving server verifies:**

```
Look up example.com public key in DNS
Verify signature matches email content
If match → PASS
```

**Strengths:**

- Cryptographically strong
- Detects any tampering with signed parts

**Limitations:**

- Signature can break with forwarding (content modified)
- Not all servers sign emails
- Complex to configure properly

---

#### DMARC (Domain-based Message Authentication)

**Purpose**: Tell receivers what to do if SPF/DKIM fail.

**DNS record example:**

```
_dmarc.example.com TXT:
"v=DMARC1; p=reject; rua=mailto:dmarc-reports@example.com"
```

**Fields:**

- `p=reject`: Reject emails that fail checks
- `p=quarantine`: Mark as spam
- `p=none`: Monitor only (no action)
- `rua`: Send aggregate reports here

**How it works:**

```
1. Check SPF
2. Check DKIM  
3. Check "alignment" (domain in From matches SPF/DKIM domain)
4. If both fail → Apply policy (reject/quarantine/none)
5. Send report to domain owner
```

**Benefits:**

- Domain owner learns about abuse
- Can gradually tighten policy (none → quarantine → reject)
- Stops spoofing of protected domains

**Limitations:**

- Adoption not universal
- Complex to configure correctly
- Legitimate forwarding can break alignment

---

### Current Reality

**Even with SPF, DKIM, DMARC:**

```
1. Not all domains implement them
2. Not all servers check them  
3. Configuration errors common
4. Legitimate email can fail checks
5. Spoofing still happens
```

**Best user practices:**

- Check sender address carefully
- Hover over links before clicking
- Verify unexpected requests through alternate channel
- Use email client with good phishing detection
- Don't trust sender address alone

---

## Summary of Key Concepts

### Hash Function Requirements

1. Arbitrary input length
2. Fixed output length
3. Deterministic
4. Efficient computation
5. Preimage resistant
6. Second-preimage resistant
7. Collision resistant

### Why Simple Hashes Fail

- Linearity enables easy collision construction
- Need non-linear operations (S-boxes, modular arithmetic)

### Merkle-Damgård Construction

- Process message block-by-block
- Chain states together
- Vulnerable to length extension attacks
- Used by MD5, SHA-1, SHA-2, Tiger

### HMAC Security

- Nested hashing prevents length extension
- Double key derivation (ipad/opad)
- Secure even with collision-prone hash

### CRC vs Cryptographic Hashes

- CRC: Fast, linear, no security
- Crypto hash: Slower, non-linear, cryptographically secure

### Secret Sharing

- Split secret via polynomial interpolation
- t-of-n threshold schemes
- Perfect secrecy with fewer than t shares

### Email Security Evolution

- SMTP: No built-in security
- SPF: Verify sending server
- DKIM: Cryptographic signatures
- DMARC: Policy enforcement

This comprehensive breakdown covers the detailed inner workings of each hashing method and related security concepts from the lecture slides.